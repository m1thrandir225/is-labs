// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: access_request.sql

package db

import (
	"context"
	"time"
)

const createAccessRequest = `-- name: CreateAccessRequest :one
INSERT INTO access_requests (user_id, resource_id, status, reason, expires_at)
VALUES (?,
        ?,
        ?,
        ?,
        ?)
RETURNING id, user_id, resource_id, status, reason, expires_at, created_at
`

type CreateAccessRequestParams struct {
	UserID     int64     `json:"user_id"`
	ResourceID int64     `json:"resource_id"`
	Status     string    `json:"status"`
	Reason     string    `json:"reason"`
	ExpiresAt  time.Time `json:"expires_at"`
}

func (q *Queries) CreateAccessRequest(ctx context.Context, arg CreateAccessRequestParams) (AccessRequest, error) {
	row := q.db.QueryRowContext(ctx, createAccessRequest,
		arg.UserID,
		arg.ResourceID,
		arg.Status,
		arg.Reason,
		arg.ExpiresAt,
	)
	var i AccessRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceID,
		&i.Status,
		&i.Reason,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAccessRequest = `-- name: GetAccessRequest :one
SELECT id, user_id, resource_id, status, reason, expires_at, created_at
FROM access_requests
WHERE id = ?
`

func (q *Queries) GetAccessRequest(ctx context.Context, id int64) (AccessRequest, error) {
	row := q.db.QueryRowContext(ctx, getAccessRequest, id)
	var i AccessRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceID,
		&i.Status,
		&i.Reason,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveAccessRequest = `-- name: GetActiveAccessRequest :one
SELECT id, user_id, resource_id, status, reason, expires_at, created_at FROM access_requests
WHERE user_id = ?
  AND resource_id = ?
  AND expires_at > ?
  AND status = 'approved'
`

type GetActiveAccessRequestParams struct {
	UserID     int64     `json:"user_id"`
	ResourceID int64     `json:"resource_id"`
	ExpiresAt  time.Time `json:"expires_at"`
}

func (q *Queries) GetActiveAccessRequest(ctx context.Context, arg GetActiveAccessRequestParams) (AccessRequest, error) {
	row := q.db.QueryRowContext(ctx, getActiveAccessRequest, arg.UserID, arg.ResourceID, arg.ExpiresAt)
	var i AccessRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceID,
		&i.Status,
		&i.Reason,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const listActiveUserAccess = `-- name: ListActiveUserAccess :many
SELECT
    ar.id, ar.user_id, ar.resource_id, ar.status, ar.reason, ar.expires_at, ar.created_at,
    r.name as resource_name
FROM access_requests ar
         JOIN resources r ON ar.resource_id = r.id
WHERE ar.user_id = ?
  AND ar.expires_at > ?
  AND ar.status = 'approved'
ORDER BY ar.expires_at
`

type ListActiveUserAccessParams struct {
	UserID    int64     `json:"user_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

type ListActiveUserAccessRow struct {
	ID           int64     `json:"id"`
	UserID       int64     `json:"user_id"`
	ResourceID   int64     `json:"resource_id"`
	Status       string    `json:"status"`
	Reason       string    `json:"reason"`
	ExpiresAt    time.Time `json:"expires_at"`
	CreatedAt    time.Time `json:"created_at"`
	ResourceName string    `json:"resource_name"`
}

func (q *Queries) ListActiveUserAccess(ctx context.Context, arg ListActiveUserAccessParams) ([]ListActiveUserAccessRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveUserAccess, arg.UserID, arg.ExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveUserAccessRow{}
	for rows.Next() {
		var i ListActiveUserAccessRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ResourceID,
			&i.Status,
			&i.Reason,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.ResourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingAccessRequests = `-- name: ListPendingAccessRequests :many
SELECT ar.id, ar.user_id, ar.resource_id, ar.status, ar.reason, ar.expires_at, ar.created_at, u.email, r.name as resource_name
FROM access_requests ar
         JOIN users u ON ar.user_id = u.id
         JOIN resources r ON ar.resource_id = r.id
WHERE ar.status = 'pending' AND r.org_id = ?
ORDER BY ar.created_at DESC
`

type ListPendingAccessRequestsRow struct {
	ID           int64     `json:"id"`
	UserID       int64     `json:"user_id"`
	ResourceID   int64     `json:"resource_id"`
	Status       string    `json:"status"`
	Reason       string    `json:"reason"`
	ExpiresAt    time.Time `json:"expires_at"`
	CreatedAt    time.Time `json:"created_at"`
	Email        string    `json:"email"`
	ResourceName string    `json:"resource_name"`
}

func (q *Queries) ListPendingAccessRequests(ctx context.Context, orgID int64) ([]ListPendingAccessRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPendingAccessRequests, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingAccessRequestsRow{}
	for rows.Next() {
		var i ListPendingAccessRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ResourceID,
			&i.Status,
			&i.Reason,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.Email,
			&i.ResourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAccessRequests = `-- name: ListUserAccessRequests :many
SELECT id, user_id, resource_id, status, reason, expires_at, created_at
FROM access_requests
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListUserAccessRequests(ctx context.Context, userID int64) ([]AccessRequest, error) {
	rows, err := q.db.QueryContext(ctx, listUserAccessRequests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccessRequest{}
	for rows.Next() {
		var i AccessRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ResourceID,
			&i.Status,
			&i.Reason,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeExpiredAccess = `-- name: RevokeExpiredAccess :exec
UPDATE access_requests
SET status = 'expired'
WHERE expires_at < current_time
  AND status = 'approved'
`

func (q *Queries) RevokeExpiredAccess(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, revokeExpiredAccess)
	return err
}

const updateAccessRequestStatus = `-- name: UpdateAccessRequestStatus :exec
UPDATE access_requests
SET status = ?
WHERE id = ?
`

type UpdateAccessRequestStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateAccessRequestStatus(ctx context.Context, arg UpdateAccessRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateAccessRequestStatus, arg.Status, arg.ID)
	return err
}
